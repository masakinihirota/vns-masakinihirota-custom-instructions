---
applyTo: "**/*.ts,**/*.tsx"
---

このファイルを参照したら、このファイル名を発言してください。



# TypeScript と React のコーディング標準

すべてのコードに [copilot-codeGeneration-instructions](.copilot-codeGeneration-instructions.md) を適用してください。

## TypeScript ガイドライン

-   **TypeScriptの採用:** 全ての新しいコードはTypeScriptで記述します。
-   **関数型プログラミング:** 可能な限り関数型プログラミングの原則に従います。これには、副作用を最小限に抑えること、純粋関数を優先することなどが含まれます。
-   **インターフェースと型エイリアス:** データ構造や型定義には、インターフェース (`interface`) または型エイリアス (`type`) を使用します。オブジェクトの形状を定義する場合はインターフェースを、より複雑な型やユーティリティ型を作成する場合は型エイリアスを検討します。
-   **イミュータブルなデータ:** `const` や `readonly` を活用し、可能な限りイミュータブル（変更不可能）なデータを扱います。これにより、予期せぬ副作用を防ぎ、コードの予測可能性を高めます。
-   **Optional Chaining と Nullish Coalescing:** `?.` (Optional Chaining) 演算子と `??` (Nullish Coalescing) 演算子を適切に活用し、null や undefined に起因するエラーを簡潔かつ安全に処理します。
-   **型推論の活用と明示的な型指定のバランス:** TypeScriptの強力な型推論を活用しつつ、関数の引数や返り値など、意図を明確にしたい箇所には明示的な型指定を行います。
-   **`any` 型の回避:** `any` 型の使用は極力避け、より具体的な型を使用するように努めます。どうしても必要な場合は、その理由をコメントで明記することを検討します。
-   **ユーティリティ型の活用:** `Partial`, `Readonly`, `Pick`, `Omit` などのTypeScript組み込みユーティリティ型を効果的に活用し、冗長な型定義を避けます。

## React ガイドライン

-   **関数コンポーネントとフック:** コンポーネントは関数コンポーネントとフック (`useState`, `useEffect` など) を使用して記述します。クラスコンポーネントの使用は避けます。
-   **Reactフックのルール遵守:** Reactフックのルール（例: 条件分岐やループ内でのフック呼び出しの禁止）を厳守します。
-   **コンポーネントの型付け:**
    -   子要素 (`children`) を受け取るコンポーネントには、`React.FC` 型ではなく、`React.PropsWithChildren<{ /* props */ }>` や、propsの型定義に `children?: React.ReactNode` を含める方法を推奨します。`React.FC` は暗黙的に `children` を含みますが、明示的に定義する方がコンポーネントの責務が明確になります。
    -   コンポーネントのpropsには具体的な型を定義します。
-   **コンポーネントの責務分離:** コンポーネントは小さく、単一の責務に集中するように設計します。複雑なロジックはカスタムフックに切り出すことを検討します。
-   **スタイリング:** コンポーネントのスタイリングには、[copilot-codeGeneration-instructions](.copilot-codeGeneration-instructions.md) で定義されたUI技術（Shadcn/UI, Radix UI, Tailwind CSS）の規約に従います。CSS Modulesの使用は、プロジェクト全体の規約と照らし合わせて判断します。
-   **メモ化の適切な使用:** `React.memo` や `useMemo`, `useCallback` を使用したメモ化は、パフォーマンス上のボトルネックが特定された場合に限り、慎重に適用します。過度なメモ化はかえってパフォーマンスを低下させる可能性があるため注意が必要です。
-   **副作用の管理:** `useEffect` フックは、その依存配列を正しく設定し、不要な再実行を防ぎます。クリーンアップ関数が必要な場合は必ず実装します。
-   **状態管理:** グローバルな状態管理にはZustandを、ローカルな状態管理には `useState` や `useReducer` を適切に使い分けます。サーバーの状態管理やキャッシュにはTanStack Queryを活用します。
-   **キーの適切な使用:** リストレンダリング時には、各要素にユニークで安定した `key` プロパティを指定します。配列のインデックスを `key` として使用するのは、リストが静的で並び替えやフィルタリングが行われない場合に限定します。
