このファイルを参照したら、このファイル名を発言してください。

# コード生成に関する指示

## 採用技術
### 2.1. 期待する役割 (エキスパートとしての振る舞い)

以下の技術スタックに精通したエキスパートとして振る舞ってください。

* **言語:** TypeScript, Node.js
* **フレームワーク/ライブラリ:** Next.js v15 (App Router), React
* **UI:** Shadcn/UI, Radix UI, Tailwind CSS
* **状態管理:** Zustand
* **バックエンド/DB:** Supabase
* **ORM:** Drizzle ORM
* **スキーマ検証:** Zod
* **決済:** Stripe
* **テスト:** Vitest, React Testing Library
* **UI コンポーネント開発/管理:** Storybook
* **API** Hono v4

### 2.2. MCP (Model Context Protocol) の設定

* MCP の設定は `.vscode/mcp.json` にあります。
* 現在の MCP の設定は `Supabase` です。 (この設定が具体的に何を意味するかは `mcp.json` を参照してください)



# コロケーション

コンポーネントに関するフォルダ、ファイルの配置方法
コロケーションを採用します。

Next.jsのApp Routerを使用し、コンポーネントのコロケーションを実現することで、プロジェクトの保守性と可読性を向上させる。具体的には、1つのページとそのページで使用する複数のコンポーネント、およびそれらのテストファイルを同一のフォルダにまとめる構成とします。

## ページ固有のデータフェッチ

場所: page.tsx または layout.tsx
理由: ページ全体で必要なデータを取得する場合、page.tsx または layout.tsx にフェッチ処理を記述します。これにより、ページ全体のデータ依存性が明確になります。

## コンポーネント固有のデータフェッチ

場所: ComponentA.logic.tsx のようなロジック専用ファイル
理由: 特定のコンポーネントでのみ必要なデータを取得する場合、ロジックを分離してComponentA.logic.tsxに記述します。これにより、コンポーネントの責務が明確になります。

## 具体的な構成

以下のディレクトリ構成を基本とします。

```
app/
  [page-name]/
    layout.tsx         // ページのレイアウトコンポーネント
    page.tsx           // ページコンポーネント
    common/        // 共通コンポーネントを格納するフォルダ
      CommonComponent.tsx       // 共通コンポーネント
      CommonComponent.logic.tsx  // 共通コンポーネントのロジックを分離したファイル
      CommonComponent.test.tsx  // 共通コンポーネントのテストファイル
    components/        // ページ固有のコンポーネントを格納するフォルダ
      ComponentA.tsx
      ComponentA.logic.tsx  // ComponentAのロジックを分離したファイル
      ComponentA.test.tsx   // ComponentAのテストファイル
      ComponentB.tsx
      ComponentB.logic.tsx  // ComponentBのロジックを分離したファイル
      ComponentB.test.tsx   // ComponentBのテストファイル
    utils/             // (必要に応じてユーティリティ関数などを格納)
      helperFunctions.ts
    [page-name].test.tsx   // ページコンポーネントのテストファイル (任意)

```



# コード生成

* コードを書く前に既存のコードを深くレビューし動作を確認します。

* 正確な例を用いて、簡潔で技術的なTypeScriptコードを記述します。

* 宣言的なJSXを記述します。
* 関数型および宣言型のプログラミングパターンを使用し、クラスの使用は避けます。
* 補助動詞（`isLoading`、`hasError`など）を用いた説明的な変数名を使用します。
* ROROパターン（Receive an Object, Return an Object: オブジェクトを受け取り、オブジェクトを返すパターン）を必要に応じて使用します。
* エクスポートされたコンポーネント、サブコンポーネント、ヘルパー、静的コンテンツ、型でファイルを構成します。
* ディレクトリ名にはケバブケースを使用します（例：`components/personal-information`）。
* コンポーネントは名前付きエクスポートを使用します。
* コンポーネント名にはケバブケースを使用します（例：`my-component.tsx`）。
* 純粋な関数には `function` キーワードを使用します。
* 単純なステートメントには簡潔な構文を使用します。
* 条件文では不要な中括弧を避け、1行文では中括弧を省略します。
* セミコロンは省略します（ただし、文の曖昧さを避けるために必要な場合は使用します）。


## コメント

* コード例を示す際は、各行の目的を詳細なコメントで説明し、実行結果も示します。
* 複雑なロジックには明確で簡潔なコメントを付けます。
* JSDOC形式のコメントを使用して、関数やコンポーネントの説明を行います。
* コメントは日本語で記述します。
* コメントは、コードの意図や動作を明確にするために使用します。

## セキュリティ

* データを危険にさらしたり、新たな脆弱性をもたらさないように、あらゆる段階で確認します。


## 2. GitHub Copilot の役割と基本設定

### 2.3. サーバーアクションの活用

* Next.jsのサーバーアクションを積極的に使用してください。
* サーバーアクションを利用することで、クライアントサイドでの状態管理やAPI呼び出しを最小限に抑え、パフォーマンスとセキュリティを向上させます。
* サーバーアクションを利用する際は、以下の点に注意してください：
  - 入力データのバリデーションにはZodを使用する。
  - エラー処理を適切に実装し、ユーザーに分かりやすいエラーメッセージを提供する。
  - サーバーアクションの戻り値として、成功時とエラー時の両方のケースをモデル化する。

## 2. GitHub Copilot の役割と基本設定

### 2.4. Hono の活用

* APIの実装には、軽量で高速なWebフレームワークであるHonoを使用してください。
* Honoを使用する際は、以下の点に注意してください：
  - ルーティングはシンプルかつ直感的に記述する。
  - ミドルウェアを活用して、認証やエラーハンドリングを効率的に実装する。
  - 型安全性を確保するために、TypeScriptの型定義を適切に使用する。
  - 必要に応じて、Honoのエコシステム（例: `hono/jwt` や `hono/cors`）を活用する。

## 2. GitHub Copilot の役割と基本設定

### 2.5. Supabase スキーマの定義

* Supabaseのスキーマは、Drizzle ORMを使用して型安全に記述してください。
* スキーマ定義の際は、以下の点に注意してください：
  - 各テーブルの型を明確に定義する。
  - 必要に応じて、リレーションや外部キーを適切に設定する。
  - 型安全性を確保するために、TypeScriptの型定義を活用する。
  - スキーマ変更時には、マイグレーションファイルを作成し、変更履歴を管理する。
