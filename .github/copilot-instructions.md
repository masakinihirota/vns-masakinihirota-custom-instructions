# GitHub Copilot 指示書 for `vns-masakinihirota`

## 概要

このプロジェクトは、`masakinihirota` Web アプリケーションを開発するためのマルチリポジトリワークスペースです。以下の関心ごとを分離したリポジトリで構成されます。

- **`vns-masakinihirota`**: コアアプリケーションコード（実装およびテスト）。
- **`vns-masakinihirota-custom-instructions`**: コーディング、デザイン、ワークフローに関するカスタム指示書。
- **`vns-masakinihirota-design`**: 設計書、ワイヤーフレーム、UI/UX ガイドライン。
- **`vns-masakinihirota-doc`**: ドキュメント、用語集、ユーザーガイド。

---

## 開発環境と主要ツール

### 開発ワークフロー

1.  **ワークスペースのセットアップ**:

    - VS Code のワークスペース機能を使用して複数のリポジトリを管理します。
    - 関連するすべてのリポジトリをワークスペースに追加し、`vns-masakinihirota.code-workspace`として保存します。
    - **ワークスペース設定例**:
      ```json
      {
        "folders": [
          { "path": "vns-masakinihirota" },
          { "path": "vns-masakinihirota-custom-instructions" },
          { "path": "vns-masakinihirota-design" },
          { "path": "vns-masakinihirota-doc" }
        ],
        "settings": {}
      }
      ```

2.  **GitHub Copilot を使ったコード生成**:

    - `vns-masakinihirota-custom-instructions` リポジトリを使用して、Copilot のプロンプトやガイダンスを定義します。
    - `#` 記号を使用して、特定のファイル、メソッド、またはクラスを参照することで、Copilot のコンテキスト認識を活用します（例：`#MyFile.cs: 66-72`）。
    - `/` コマンドを使用して、テスト生成（`/tests`）やコード最適化（`/optimize`）などのタスクを実行します。

3.  **設計とドキュメント**:

    - 設計関連のすべての資料は `vns-masakinihirota-design` に保存します。
    - ユーザー向けドキュメントや内部ガイドは `vns-masakinihirota-doc` に保存します。

4.  **フィードバックと反復**:

    - 以下のフィードバックループに従います：**設計 → 指示書 → コード → レビュー → ドキュメント → フィードバック → 設計**。

### 主要ツールと依存関係

- **技術スタック**: **TypeScript、Node.js、Next.js (App Router)、React、Shadcn/UI、Radix UI、Tailwind CSS、Zustand、Supabase、Drizzle ORM、Zod、Stripe**。
- **テスト**: **Vitest、React Testing Library、Storybook**。
- **ドキュメント生成**: **vitepress**。
- **その他**: Sentry, Framelink Figma, Postgres (LOCAL-supabase), git, Sequential Thinking, github, MarkItDown, Context7, Playwright, serena。
- その他の依存関係については、`vns-masakinihirota` の `package.json` を参照してください。

---

## プロジェクト固有の規約

### 1. コーディング規約とフォルダ構造

- **品質**: **性能よりもシンプルさを優先**し、可読性と保守性の高いコードを目指します。

- **スタイル**: **関数型および宣言型のプログラミングパターンを推奨**し、クラスの使用は極力避けてください。

- **命名**: 補助動詞（`isLoading`、`hasError`など）を用いた説明的な変数名を使用してください。純粋な関数には `function` キーワードを使用してください。

- **ファイルサイズ**: **1 ファイルあたりの行数は 500 行以内**にしてください。ファイルがこの制限に近づいたら、モジュールやヘルパーファイルに分割してリファクタリングしてください。

- **モジュール化**: 機能または責任ごとに、明確に分離されたモジュールにコードを整理してください。

- **型**: **`any`を使用しないでください**。厳密な型安全を設定してください。

- **セミコロン**: セミコロンは省略します（ただし、文の曖昧さを避けるために必要な場合は使用する）。

- **コメント**: JSDoc を使った明確なコンテキストを書いてください。コードを修正したらコメントも適切なものにしてください。不要なコメント、食い違いのあるコメントは削除してください。

- **フォルダ構造**: 基本的な Next.js App Router の構造に従い、コンポーネントの配置は**コロケーションパターン**を適用します。ルーティング(App router)とコンポーネントは見やすいように分離し、コンポーネントの集合を１ページ単位として小さなミニアプリを構築するイメージです。

  ```
  - `src/`
    - `app/`
      - `page.tsx` # ルートページ
      - `route1/`
        - `page.tsx` # ルート 1 のページ
        - `layout.tsx` # ルート 1 のレイアウト
        - `index.ts` # route1 ページで使用するコンポーネントをエクスポート
      - `route2/`
        - `page.tsx` # ルート 2 のページ
    - `components/`
      - `common/` # 共通コンポーネント
        - `Button/`
          - `Button.tsx`
          - `Button.test.tsx`
          - `Button.stories.tsx`
        - `Input/`
          - `Input.tsx`
          - `Input.test.tsx`
          - `Input.stories.tsx`
      - `route1/` # route1 ページ用のコンポーネント群
        - `ComponentA/` # コンポーネント A
          - `ComponentA.container.tsx` # Container 層
          - `ComponentA.ui.tsx` # UI 層
          - `useComponentA.ts` # Hooks (ビジネスロジック)
          - `ComponentA.fetch.ts` # データフェッチ
          - `ComponentA.test.ts` # テスト
          - `ComponentA.stories.tsx` # Storybook ストーリー
        - `ComponentB/` # コンポーネント B (上記に準ずる)
        - `index.ts` # route1 配下のコンポーネントをまとめてエクスポート
    - `lib/` # グローバルなユーティリティ、型定義など
    - `utils/` # グローバルなユーティリティ、型定義など
  ```

### 2. コンポーネントの責務と命名規則

各ファイルの役割を明確にし、以下のルールに従ってコードを生成してください。

- **UI 層 (`xxx.ui.tsx`)**:

  - **役割**: 純粋に見た目とインタラクションを担当。props を受け取って表示し、レイアウトを定義。
  - **やっていいこと**: props の表示、UI インタラクション、レイアウト。
  - **やってはダメなこと**: **`useState`、`useEffect`、API 呼び出し（データフェッチは Container/Hooks/Server Components に任せる）**。
  - **テスト**: Visual Regression Test (VRT) や Storybook で見た目のみのテストを行うことを念頭に置く。

- **Container 層 (`xxx.container.tsx`)**:

  - **役割**: データ取得とロジックの統合を担当。Hooks を呼び出し、UI コンポーネントに props を渡し、Composition によって子コンポーネントを注入。UI とロジックの橋渡し役。
  - **やっていいこと**: Hooks の呼び出し、UI への props 渡し、Composition。
  - **やってはダメなこと**: 直接的な DOM 操作、スタイリング。

- **Hooks (`useXxx.ts`)**:

  - **役割**: 再利用可能なビジネスロジックを担う。状態管理、API 呼び出し、計算処理などを行う。
  - **やっていいこと**: 状態管理、API 呼び出し、計算処理。
  - **やってはダメなこと**: JSX の return、UI 固有の処理。
  - **テスト**: UI の描画確認不要で、ビジネスロジックの単体テストを行う。

- **Composition**:

  - **役割**: 外部からコンポーネントを合成・注入することで、UI 層でのコンポーネントの深いネストを避ける。Container 層で Composition を行う。

- **データフェッチ (`xxx.fetch.ts` または Server Components)**:

  - **役割**: データ取得ロジックを分離。**Next.js の公式推奨に従い、データフェッチはサーバーコンポーネント (`page.tsx` や `layout.tsx`) で行うことを優先**し、結果を props としてコンポーネントに渡すことで再利用性とテスト容易性を高める。
  - Server Actions や tRPC もデータフェッチの方法として利用可能。

### 3. テスト規約

- **配置**: 基本的にテストは `vns-masakinihirota` リポジトリ内に配置します。コンポーネントのテストはコロケーションの考え方により１ページ単位で配置します（関連するコンポーネントと同じフォルダ内に配置）。
- **種類**: 関数はユニットテスト、コンポーネントは React Testing Library を用いたコンポーネントテスト、そして統合テストも考慮します。
- **フレームワーク**: **Vitest と React Testing Library**を使用してください。
- **記述形式**:
  - テストケースは**日本語**で記述してください。
  - テストは `describe` でグループ化し、`it` でテストケースを記述してください。
- **網羅性**:
  - 全ての新しい機能にユニットテストを記述してください。
  - 予想される使用に対するテスト、1 つのエッジケースのテスト、1 つの失敗ケースのテストを少なくとも含めてください。
  - DB や GitHub Copilot のようなサービスへの呼び出しは、常に**モック**を使用してください。
- **更新**: ロジックを変更した場合は、既存のユニットテストを更新する必要があるか確認し、必要に応じて更新してください。
- **テストの目的 (AI 駆動開発の場合)**: GitHub Copilot によるコード生成を「変更」と捉え、テストの主目的は**レグレッションテスト**とします。既存機能が意図せず損なわれていないか、生成されたコードが設計書通りに動作するかを確認してください。

### 4. ドキュメント規約

- 機能を追加または変更する際は、必ず `vns-masakinihirota-doc` を更新します。
- `README.md` には、使い方や説明などを記述し、変更内容は常に反映させてください。
- コードとドキュメントは同時に記述することを推奨します。

---

## GitHub Copilot の振る舞いとルール

GitHub Copilot は、上記の技術スタックと設計原則に精通したエキスパートとして振る舞ってください。

### 遵守事項 (DO's)

- **コンテキスト**: コンテキストが不明な場合は、積極的に質問してください。
- **タスク集中**: プロジェクトの修正や変更を行う際は、**一度に 1 つのタスクに集中**してください。
- **履歴管理**: 変更、修正があった場合、メモリーファイル `memory.md` を更新してください。コード変更後は、タスクリストファイル `task-list.prompt.md` を更新してください。
- **環境変数**: 環境変数は `.env` ファイルおよび `.env.local` ファイルで管理し、Next.js の仕組みに従って安全に利用してください。環境変数の実装は、開発者が責任を持って行ってください。

### 避けるべきこと (DON'Ts)

- **ライブラリ**: 存在しないライブラリや関数は使用せず、既知の、検証されたライブラリのみを使用してください。
- **ファイルパス**: コードやテストで参照する前に、ファイルパスやモジュール名が存在することを確認してください。
- **既存コードの変更**: 明示的に指示されていない限り、または `task-list.prompt.md` のタスクに含まれていない限り、既存のコードを削除または上書きしないでください。
- **過信しない**: GitHub Copilot はコーディングエージェント、アシストツールであり、完全な自動化ツールではありません。複雑なロジックや高度な設計判断は、分解して問題を小さくするか、人間の手で行う必要があります。自動生成だからテストを書かなくていい、盲目的に GitHub Copilot を信用するといったことはしないでください。
- **失敗コードの破棄**: 失敗したコードは破棄しましょう。サンクコストにとらわれず、プロジェクトに沿わないコードを残さないでください。
- **AI の限界**: AI は自分の限界を知るのが苦手です。実行できることのみを実装するように依頼することが重要です。難しい問題の場合、人間ならば途中で立ち止まりますが、AI はタスクを忠実に完了させようと進み続けます。
- **技術的負債**: コードの重複、複雑すぎるコード、テストがないコード、ドキュメントがないコード、パフォーマンスが悪いコード、セキュリティ上の問題があるコードを**技術的負債**と定義します。リファクタリング、テストの追加、ドキュメントの作成、パフォーマンス改善、セキュリティ修正を積極的に行い、**技術的負債を徹底的に無くしてください**。小さな違和感を放置せず、後回しにしない。
- **リファクタリングの怠り**: AI はコードをコピーする傾向があります。重複を減らすように積極的にリファクタリングを提案し、人間がレビューすることを促してください。AI は指示がない限り、積極的にリファクタリングしようとはしません。
