このファイルを参照したら、このファイル名を発言してください。

# このプロジェクトのワークスペースのリポジトリ構成

このプロジェクトは、
以下のリポジトリをVS Codeワークスペースで統合しています。

1. **Webアプリリポジトリ:** `vns-masakinihirota`
1. **指示書リポジトリ:** `vns-masakinihirota-custom-instructions`
3. **設計書リポジトリ:** `vns-masakinihirota-design`
4. **タスクリストリポジトリ:** `vns-masakinihirota-design-task-list`
5. **公開ドキュメントリポジトリ:** `vns-masakinihirota-doc`
5. **サンプルリポジトリ:** `vns-masakinihirota-sample`



# GitHub Copilot 指示書

このファイルは、GitHub Copilot に対するプロジェクト全体の基本的な指示を記述するものです。

## 1. 指示書の全体像と優先順位

開発プロセスでは、複数の指示書ファイルを参照します。

* GitHub Copilot プロンプト用ルール: `.github/prompts`
フォルダ内の個別のタスク指示書 (`[YYYYMMDD]-[タスクid]-[タスク名]-[タスクの種類].prompt.md`) -
* メモリーバンク: `_memory-bank/_memory-bank-instructions.md` (過去の会話や作業内容の記録。会話開始時に読み込む)


### 指示書のファイル構成

```
.
├── _memory-bank
│   └── _memory-bank-instructions.md          # メモリーバンク指示
├── .github
│   ├── prompts        (プロンプトファイル)
│   │   ├── completes # (使用目的不明瞭)
│   │   └── [YYYYMMDD]-[タスクid]-[タスク名]-[タスクの種類].prompt.md
│   ├── .copilot-codeGeneration-instructions.md # コード生成指示 (個別の指示書)
│   ├── .copilot-commit-message-instructions.md # コミットメッセージ指示 (個別の指示書)
│   ├── .copilot-review-instructions.md       # レビュー指示 (個別の指示書)
│   ├── .copilot-task-instructions.md         # タスク指示 (個別の指示書)
│   ├── .copilot-test-instructions.md         # テスト指示 (個別の指示書)
│   ├── .supabase-instructions.md             # Supabase連携指示 (個別の指示書)
│   └── copilot-instructions.md               # このファイル (全体指示)
└── README-copilot-instructions.md            # (この指示書に関する説明)

```

### 1.2. 指示書の優先順位

指示内容が競合する場合、以下の優先順位に従ってください。

1.  **メモリーバンク:** `_memory-bank/_memory-bank-instructions.md` (過去の経緯や決定事項)
2.  **プロンプトファイル:** `.github/prompts/` 内のタスク指示書
3.  **個別の指示書:** `.github/` 内の `.copilot-*-instructions.md` など
4.  **全体の指示書:** このファイル (`.github/copilot-instructions.md`)



## 3. Web アプリ開発の手順

1.  **設計書の作成:** 設計書を確認します。
2.  **タスク分解:** 設計書をもとに、実装可能な単位（通常は1機能1タスク）にタスクを分解します。
3.  **タスクリスト作成/更新:** 分解したタスクをこのタスクリスト
(`vns-masakinihirota-design-task-list\_task-list.md`)
に登録・更新します。

4.  **プロンプトファイル作成:** 各タスクについて、詳細な実装指示を記述したプロンプトファイル (`.github/prompts/`) を作成します。開発者は必要に応じて情報を補強します。
5.  **実装:** GitHub Copilot は、承認されたプロンプトファイルに基づいてコードを生成・修正します。
6.  **テスト:** 実装された機能に対して、ユニットテスト、結合テスト、E2Eテストなどを記述・実行します。
7.  **レビューとリファクタリング:** 生成されたコードを確認し、技術的負債がないか、改善点はないかなどを検討します。問題があればリファクタリングを行います。ソースコードのみを見て批判的な分析も行います。
8.  **コミット:** テストとレビューが完了したコードをバージョン管理システムにコミットします。
9.  **繰り返し:** 設計書の全ての機能が実装されるまで、手順 4〜8 を繰り返します。

## 4. タスク管理の詳細

### 4.1. タスクリストファイル (`_task-list.md`)

* **役割:** プロジェクト全体のタスクを一覧化し、進捗を管理します。

* **作成/更新:**
    * 設計書に基づいてタスクを分解し、このファイルに登録します。
    * 各タスクには一意のタスクIDを割り当てます。
    * 現在進行中のタスク、未着手のタスクを明確にします。
    * 完了したタスクは、完了後速やかにチェックマーク (`[x]`) を付けます。GitHub Copilot が更新を指示されることもあります。（例: 「`_task-list.md` のタスクID `xxx` が完了したのでチェックしてください。」）
    * 開発中に新たに発見されたタスクや TODO は、「作業中に発見」などのセクションに適宜追加します。

### 4.2. プロンプトファイル (`.github/prompts/`)

* **役割:** 個別のタスク（1機能）に関する詳細な指示を記述します。GitHub Copilot はこのファイルに基づいて作業を行います。
* **作成ルール:**
    * 原則として、1タスク（1機能）につき1つのプロンプトファイルを作成します。
    * ファイル名は以下の命名規則に従います。
        `.github/prompts/[YYYYMMDD]-[タスクid]-[タスク名]-[タスクの種類].prompt.md`
        * `[YYYYMMDD]`: 作成日 (例: 20240426)
        * `[タスクid]`: `_task-list.md` で割り当てられたID (例: 123)
        * `[タスク名]`: タスクの内容がわかる簡潔な名前 (例: loginFeature)
        * `[タスクの種類]`:
            * `feat`: 新機能開発
            * `fix`: バグ修正
            * `test`: テスト関連
            * `doc`: ドキュメント関連
            * `refactor`: リファクタリング
            * `style`: スタイル調整
            * その他、必要に応じて定義
        * 例: `.github/prompts/20240426-123-loginFeature-feat.prompt.md`
* **実行手順:**
    * 指示されたプロンプトファイルに基づいて、ファイル内に書かれた指示を実行します。
    * 実行前に `_task-list.md` を確認し、現在のタスク状況を把握してください。
    * 実行時には、この `copilot-instructions.md` を含む、関連する全ての指示書ルールに従います。

### 4.3. プロンプトファイル完了後の処理

プロンプトファイルに基づくタスクが完了したら、以下の処理を行います。

1.  **タスクリストファイルの更新:** 完了したタスクにチェックマークを付けます。(`4.1. タスクリストファイル` 参照)
2.  **コードレビューと改善:**
    * **客観的レビュー:** プロジェクトの背景情報を見ずに、ソースコードのみを読み、コードや設計に対する批判的な分析や改善提案を行ってください。
    * **非推奨コードの削除:** 全ての `deprecated` なコードを削除します。新しい仕組みへ移行する際、中途半端な状態を残さないようにしてください。
    * **技術的負債の解消:** 技術的負債を特定し、積極的に解消します。

### 4.4. 技術的負債

* **定義:** 以下のような状態を技術的負債とみなします。
    * コードの重複
    * 過度に複雑なコード (可読性・保守性の低いコード)
    * テストコードが不足している、または存在しないコード
    * ドキュメントが不足している、または実態と乖離しているコード
    * パフォーマンス上の問題があるコード
    * セキュリティ上の脆弱性があるコード
* **解消方法:**
    * リファクタリング (コードの構造改善)
    * テストコードの追加・修正
    * ドキュメントの作成・更新
    * パフォーマンスチューニング
    * セキュリティ修正

## 5. GitHub Copilot の動作ルール

* **不明点の確認:** 指示内容やコンテキストが不明確な場合は、必ず質問してください。
* **ライブラリ/関数の使用:** 存在しない、あるいは検証されていないライブラリや関数は使用しないでください。既知で信頼できるもののみを使用します。
* **パス/モジュールの確認:** コードやテストでファイルパスやモジュール名を参照する前に、それらが実際に存在することを確認してください。
* **既存コードの扱い:** 明示的に指示されていない限り、または `_task-list.md` のタスクに含まれていない限り、既存のコードを削除したり上書きしたりしないでください。
* **タスクへの集中:** プロジェクトの修正や変更を行う際は、一度に 1 つのタスクに集中してください。
* **メモリーバンクの活用:**
    * 新しい会話を開始する際は、必ずメモリーバンク (`_memory-bank/_memory-bank-instructions.md`) を読み込み、過去の会話や作業内容を把握した上で作業を再開してください。
    * 作業内容に変更や修正があった場合は、メモリーバンクを更新してください。（更新が必要な場合は、その旨を指示します）
* **タスクリストの更新:** コード変更後など、タスクの状況に変化があった場合は、`_task-list.md` を更新してください。（更新が必要な場合は、その旨を指示します）

## 6. コーディング規約

### 6.1. 基本方針

* **シンプルさ優先:** 複雑な実装よりも、シンプルで理解しやすいコードを優先してください。
* **プログラミングパラダイム:** 関数型プログラミングおよび宣言的なパターンを推奨します。クラスの使用は最小限に留めてください。
* **コンポーネントのコロケーション:** コンポーネントに関連するファイル（ビュー、ロジック、フック、テスト、ストーリーなど）は、可能な限り同じフォルダ内に配置してください。
* **型安全性:** `any` 型の使用は原則禁止です。常に型安全なコードを記述してください。
* **ファイル行数:** 1ファイルあたりの行数は原則として 500 行以内に収めてください。これを超えそうな場合は、モジュール分割やヘルパー関数の作成によるリファクタリングを検討してください。
* **モジュール分割:** 機能や責務ごとに、明確に分離されたモジュールにコードを整理してください。
* **曖昧さの指摘:** 指示内容が曖昧な場合は、その点を指摘し、具体的な指示を求めてください。
* **互換性の排除:** 古い機能やコードとの互換性は維持せず、完全に新しい方式に置き換えてください。

### 6.2. コードコメント

* **形式:** TSDoc 形式を使用し、関数や複雑なロジックにはその目的や動作、パラメータ、返り値など、十分なコンテキストがわかるコメントを記述してください。
* **同期:** コードを修正した場合は、関連するコメントも必ず更新してください。コードとコメントの内容が一致するように保ちます。
* **整理:** 不要になったコメントは削除してください。

### 6.3. 環境変数

* 環境変数は `.env` ファイルおよび `.env.local` ファイルで管理します。
* Next.js の仕組みに従って、サーバーサイドとクライアントサイドでの環境変数の扱いに注意し、安全に利用してください。

## 7. テストに関する指示

### 7.1. 基本方針

* 全ての主要な関数にはユニットテストを記述してください。
* 全ての新しい機能にはユニットテストを記述してください。
* ロジックを変更した場合は、関連する既存のユニットテストを見直し、必要に応じて更新してください。

### 7.2. 使用ツールと記述方法

* **ユニットテスト:** Vitest を使用します。
* **React コンポーネントテスト:** React Testing Library を使用します。
* **記述形式:** テストは `describe` ブロックでグループ化し、個々のテストケースは `it` ブロックで記述します。テストケースの名称（`it` の第一引数）は、テスト内容が明確にわかるように**日本語**で記述してください。

### 7.3. テストの配置 (コロケーション)

* テストファイルは、テスト対象のコンポーネントやモジュールと同じフォルダ内に配置してください。

### 7.4. テストケースの種類

* 各機能やコンポーネントに対して、少なくとも以下の種類のテストケースを含めてください。
    * **正常系:** 期待される通常の利用シナリオに対するテスト。
    * **異常系 (エッジケース):** 境界値や予期せぬ入力など、通常とは異なる状況での動作を確認するテスト。
    * **異常系 (失敗ケース):** 意図的にエラーを発生させ、適切なエラーハンドリングが行われるかを確認するテスト。

### 7.5. テストのベストプラクティス

* **モックの使用:** データベースや外部 API (Supabase, Stripe など)、あるいは GitHub Copilot 自身のような外部サービスへの依存がある場合は、テスト時には必ずモックを使用してください。実際のサービスへ接続しないようにします。

## 8. UI に関する指示

* **デザイン:** UI はシンプルで直感的、かつ使いやすいデザインを心がけてください。
* **レスポンシブ:** モバイルデバイスでの表示を考慮した、レスポンシブデザインを実装してください。
* **変更:** UI/UX デザイン（レイアウト、色、フォント、間隔など）の変更は原則として行わないでください。変更が必要な場合は、「13. 作業に関する重要な注意点」に従い、事前に提案し承認を得てください。

## 9. ドキュメント

* プロジェクトの概要、セットアップ方法、使い方、アーキテクチャの説明などは、ルートディレクトリの `README.md` に記述してください。
* プロジェクトに重要な変更を加えた場合は、`README.md` の内容も適宜更新してください。

## 10. セキュリティ

* `.env` や `.env.local` など、機密情報を含む可能性のあるファイルは、`.gitignore` に追加し、Git リポジトリで管理しないでください。
* GitHub Copilot によって提案されたコード（特にセキュリティ関連や外部入力処理部分）は、鵜呑みにせず、必ず開発者が内容を検証し、潜在的な脆弱性がないか確認してください。

## 11. エラー確認と記録

エラーが発生した場合や予期せぬ動作をした場合は、以下の手順で対応し、記録を残してください。

1.  **一次対応:**
    * プロンプトの内容を見直す。
    * 与えているコンテキスト（ファイルや選択範囲）が適切か確認する。
    * 再生成を試みる。
    * 明らかな間違いであれば、簡単な修正を試みる。
2.  **詳細調査と切り分け:** 問題が解決しない場合、以下の情報を収集します。
    * エラーメッセージの全文。
    * 問題が発生している具体的なコード箇所。
    * 使用している Copilot、IDE、OS のバージョン。
    * 問題を再現させるための具体的な手順。
    * 関連するログファイルの内容（IDEのログ、サーバーログなど）。
3.  **対策検討と実施:** 収集した情報をもとに原因を特定し、対策を検討・実施します。
4.  **動作検証と記録:** 対策後、問題が解決したかを確認します。検証項目、期待される結果、実際の動作結果、実施した対応策を記録に残します。
5.  **ログ確認と分析:** 必要に応じて、デバッグログなどを有効化し、詳細な動作を確認・分析します。エラーログはconsole.error 等を使用してください。

## 12. メモリーバンク

* プロジェクトに関する過去の会話履歴、決定事項、重要なコンテキストなどを記録・参照するために、プロジェクト単位でメモリーバンクを利用します。
* メモリーバンクの具体的な利用方法については、`_memory-bank/_memory-bank-instructions.md` および関連する `README.md` を確認してください。
* 新しい会話を始める際には、必ずメモリーバンクを読み込んでください。

## 13. 作業に関する重要な注意点 (開発者・Copilot 共通)

### 13.1. 作業開始前

* **不明点の確認:** 指示内容や仕様に不明な点があれば、作業を開始する前に必ず質問し、疑問点を解消してください。

### 13.2. 作業中

* **重要判断の承認:** アーキテクチャの変更や仕様に関わる重要な判断が必要な場合は、自己判断せず、必ず報告し承認を得てください。
* **問題発生時の報告:** 予期せぬ問題（エラー、仕様上の矛盾など）が発生した場合は、速やかに報告し、対応策を提案してください。
* **未指示変更の禁止:** 明示的に指示されていない変更は行わないでください。必要と思われる変更がある場合は、まずその理由とともに提案として報告し、承認を得てから実施してください。
* **技術スタックの変更禁止:** 使用する技術（フレームワーク、ライブラリ、ツール、API 等）は、許可なく変更しないでください。変更が必要な場合は、その理由を明確に説明し、承認を得てください。
* **UI/UX デザイン変更の禁止:** UI/UX デザイン（レイアウト、色、フォント、アイコン、間隔など）は、許可なく変更しないでください。変更が必要と思われる場合は、具体的な理由と変更案を示し、承認を得てください。



# SOLIDの原則

S: Single Responsibility Principle（単一責任の原則）
O: Open/Closed Principle（オープン/クローズドの原則）
L: Liskov Substitution Principle（リスコフの置換原則）
I: Interface Segregation Principle（インターフェース分離の原則）
D: Dependency Inversion Principle（依存性逆転の原則）

1. **S: Single Responsibility Principle（単一責任の原則）**
   - クラスやモジュールは、1つの責任（機能）だけを持つべきであり、その責任を変更する理由は1つだけであるべきです。
   - 目的：コードの可読性と保守性を向上させる。

2. **O: Open/Closed Principle（オープン/クローズドの原則）**
   - ソフトウェアエンティティ（クラス、モジュール、関数など）は拡張に対して開かれており、修正に対して閉じられているべきです。
   - 目的：既存のコードを変更せずに新しい機能を追加できるようにする。

3. **L: Liskov Substitution Principle（リスコフの置換原則）**
   - サブクラスは、その親クラスと置き換え可能でなければなりません（親クラスのインスタンスをサブクラスで置き換えても動作が変わらない）。
   - 目的：継承関係の正当性を保証し、予期しない動作を防ぐ。

4. **I: Interface Segregation Principle（インターフェース分離の原則）**
   - クライアントは、自分が使用しないメソッドに依存してはならない（インターフェースは小さく、特化したものに分割すべき）。
   - 目的：不要な依存関係を減らし、柔軟性を高める。

5. **D: Dependency Inversion Principle（依存性逆転の原則）**
   - 高レベルモジュールは低レベルモジュールに依存してはならず、両者とも抽象に依存すべきです。また、抽象は詳細に依存してはならず、詳細が抽象に依存すべきです。
   - 目的：モジュール間の結合度を下げ、柔軟性と再利用性を向上させる。

