DBを指示するAIとして、データベース設計において以下のアンチパターンを回避し、最適なアプローチを採用するための指示書を以下に示します。これらの指示は、提供されたソースからの情報に基づいています。

# アンチパターン資料ファイル一覧

- [ch01_Introduction.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch01_Introduction.txt)
- [ch02_Jaywalking.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch02_Jaywalking.txt)
- [ch03_Trees.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch03_Trees.txt)
- [ch04_ID-Required.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch04_ID-Required.txt)
- [ch05_Keyless-Entry.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch05_Keyless-Entry.txt)
- [ch06_EAV.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch06_EAV.txt)
- [ch07_Polymorphic.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch07_Polymorphic.txt)
- [ch08_Multi-Column.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch08_Multi-Column.txt)
- [ch09_Metadata-Tribbles.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch09_Metadata-Tribbles.txt)
- [ch10_Rounding-Errors.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch10_Rounding-Errors.txt)
- [ch11_31-Flavors.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch11_31-Flavors.txt)
- [ch12_Phantom-Files.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch12_Phantom-Files.txt)
- [ch13_Index-Shotgun.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch13_Index-Shotgun.txt)
- [ch14_Fear-Unknown.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch14_Fear-Unknown.txt)
- [ch15_Groups.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch15_Groups.txt)
- [ch16_Random.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch16_Random.txt)
- [ch17_Search.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch17_Search.txt)
- [ch18_Spaghetti-Query.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch18_Spaghetti-Query.txt)
- [ch19_Implicit-Columns.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch19_Implicit-Columns.txt)
- [ch20_Passwords.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch20_Passwords.txt)
- [ch21_SQL-Injection.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch21_SQL-Injection.txt)
- [ch22_Neat-Freak.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch22_Neat-Freak.txt)
- [ch23_See-No-Evil.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch23_See-No-Evil.txt)
- [ch24_Diplomatic_immunity.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch24_Diplomatic_immunity.txt)
- [ch25_Procedures.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch25_Procedures.txt)
- [ch26_Foreign_key_standard.txt](U:\2025src\___masakinihirota\vns-masakinihirota-design\1000-参考資料資料\アンチパターン\ch26_Foreign_key_standard.txt)

---

### **AI向けデータベース設計指示書：アンチパターン回避のための原則**

AIよ、データベース設計を指示する際、以下の原則とアンチパターン回避策を厳守し、効率的で堅牢なシステム構築に貢献しなさい。

#### **1. アンチパターンの理解と設計プロセス**
*   **アンチパターンとは、問題を解決しようとした結果、他の問題を生じさせてしまう技法であることを理解しなさい**。
*   データベース設計を進める前に、以下のカテゴリーのアンチパターンを考慮し、それぞれの目的、アンチパターン、見つけ方、例外、そして解決策を明確に評価しなさい。
    *   データベース論理設計のアンチパターン
    *   データベース物理設計のアンチパターン
    *   クエリのアンチパターン
    *   アプリケーション開発のアンチパターン

#### **2. 複数の値を持つ属性の格納**
*   **アンチパターン「ジェイウォーク（信号無視）」を避けてください。単一の列にカンマ区切りフォーマットのリストで複数の値を格納してはなりません**。これは、クエリの複雑化、パフォーマンスの低下、データ整合性の問題（例: 無効な入力の許可、外部キー制約の不適用）、およびメンテナンスの困難さを引き起こします。
*   **解決策として、交差テーブルを作成して多対多の関係を表現しなさい**。これにより、各値を個別の行として格納し、外部キー制約によるデータ検証、効率的な結合、容易な更新・削除、および区切り文字の懸念の解消が可能になります。
*   **アンチパターン「マルチカラムアトリビュート（複数列属性）」を避けてください。複数の値を持つ可能性のある単一の属性のために、複数の列（例: `tag1`, `tag2`, `tag3`）を定義してはなりません**。これは、クエリの冗長化、値の追加・削除の複雑化、一意性の保証の失敗、および値の数の固定化による柔軟性の欠如を招きます。
*   **解決策として、従属テーブルを作成し、そこに属性の値を単一の列に格納しなさい**。複合主キーを活用することで、値の重複を防ぎ、タグ付けのような多値属性を柔軟かつ効率的に管理できます。
*   （ミニアンチパターンより）**変動する「事実」の値（例: 購入時の価格、過去のチームメンバー）は、冗長に見えてもその時点の真実としてテーブルに格納しなさい**。

#### **3. 階層構造の格納**
*   **アンチパターン「ナイーブツリー（素朴な木）」を避けてください。階層構造データを扱う際、隣接リストモデル（`parent_id`のみに依存）を無制限の深さのツリーの全子孫や先祖を取得する目的で直接使用してはなりません**。これは、クエリの複雑化、固定された深さの階層しか扱えない問題、パフォーマンス低下、およびメンテナンスの困難さを招きます。
*   **解決策として、再帰クエリ（Recursive CTE）を利用しなさい**（データベースがサポートしている場合）。
*   より堅牢な解決策として、**閉包テーブル（Closure Table）** を採用しなさい。これは、直接の親子関係だけでなく、ツリー全体のパスを格納する追加テーブルを用い、多様なクエリと参照整合性を可能にします。
*   （ミニアンチパターンより）**開発環境と本番環境のデータベースバージョンは可能な限り一致させなさい**。新しいSQL構文（例: `WITH`句）に依存するコードは、古い本番環境でエラーとなる可能性があります。

#### **4. 主キーの規約と管理**
*   **アンチパターン「IDリクワイアド（とりあえずID）」を避けてください。全てのテーブルに汎用的な「id」列を主キーとして無条件に設定してはなりません**。
*   **主キーには、そのエンティティを識別する分かりやすい列名を付けてください**（例: `Bugs`テーブルには`bug_id`、`Products`テーブルには`product_id`）。
*   自然キー（一意であることが保証され、意味を持つ列）や複合キー（複数の列の組み合わせで一意性を保証）がテーブルの行を一意に識別できる場合は、**それらを主キーとして活用しなさい**。これにより、冗長なキーの作成や重複行の発生を防ぎ、キーの意味を明確に保てます。
*   （ミニアンチパターンより）**自動インクリメントされる`BIGINT`型のIDは、通常、アプリケーションの存続期間中に十分な容量を提供するため、枯渇を心配する必要はありません**。
*   **アンチパターン「シュードキー・ニートフリーク（疑似キー潔癖症）」を避けてください。自動インクリメントされる疑似キーに欠番を埋めたり、既存の疑似キー値を再割り当てしたりしてはなりません**。これは、キー生成の複雑化、並行処理の問題、データ整合性の破壊、外部システム参照の無効化、およびIDの再利用による曖昧な追跡不能な状況を引き起こします。
*   **疑似キーの欠番は埋めず、それらが一意の識別子であることを理解しなさい**。欠番は行の削除やロールバックの正常な結果です。
*   レポートや表示のために連続した番号が必要な場合は、**ウィンドウ関数（例: `ROW_NUMBER()`）を使用して結果セットに行番号を付与しなさい**。
*   グローバルな一意性が必要な場合は、**GUID（UUID）を主キーとして使用することも検討しなさい**。
*   （ミニアンチパターンより）**グループごとの自動インクリメントは避けてください**。これも並行処理の問題を引き起こします。

#### **5. 参照整合性と外部キー**
*   **アンチパターン「キーレスエントリ（外部キー嫌い）」を避けてください。外部キー制約を使用しない設計は行ってはなりません**。これにより、アプリケーションコードに参照整合性の維持という重い責任が押し付けられ、データ不整合、パフォーマンス問題、およびコードの複雑化を招きます。
*   **必ず外部キー制約を宣言し、データベースに参照整合性を強制させなさい**。
*   `ON UPDATE CASCADE`や`ON DELETE CASCADE`/`SET DEFAULT`/`RESTRICT`などのアクションを適切に利用し、関連するデータの変更を自動的に処理するように設定しなさい。これはデータの一貫性を保ち、コード量を削減し、バグを未然に防ぐ「ポカヨケ」の原則に基づきます。
*   **アンチパターン「ポリモーフィック関連」を避けてください。複数の親テーブルを参照する「ポリモーフィック関連」（二重目的の外部キー）は使用してはなりません**。この設計は、**外部キー制約を宣言できず**、データの参照整合性を保証できません。また、クエリが複雑で非効率になります。
*   **解決策として、参照を逆向きにして、親テーブルごとに交差テーブルを作成するか**、**共通の基底テーブルを作成し、子テーブルからその基底テーブルを参照する**方法 を採用しなさい。これらの方法は、参照整合性を維持し、クエリを簡素化できます。
*   外部キー制約を宣言する際には、**標準SQLの要件を厳密に遵守しなさい**。以下の誤った使い方を避けてください。
    *   1対多リレーションシップにおいて、**親テーブル側で外部キーを定義してはなりません**。
    *   **まだ作成されていないテーブルを参照する外部キーを定義してはなりません**。
    *   外部キーは、参照される親テーブルの**`PRIMARY KEY`または`UNIQUE KEY`の列をすべて参照しなければなりません**。
    *   複合主キーを参照する場合、**外部キーは単一の制約として定義し、参照される列の順序を親テーブルの定義と一致させなさい**。
    *   子テーブルの外部キー列は、親テーブルの参照列と**データ型を完全に一致させなさい**。
    *   文字列型の列の場合、**文字照合順序（collation）も一致させなさい**。
    *   既存のデータに孤立行がある子テーブルに外部キーを追加する際は、**先に孤立行を修正または削除しなさい**。
    *   `ON DELETE SET NULL`または`ON UPDATE SET NULL`アクションを使用する場合、**対象の外部キー列を`NULL`許容として定義しなさい**。
    *   **スキーマ全体で一意でない制約識別子を作成してはなりません**。
    *   **互換性のないテーブルタイプ間で外部キーを定義してはなりません**（例: 永続テーブルと一時テーブル）。
*   MySQLで外部キーを定義する際には、**MySQL固有の制限と振る舞いを理解し、以下の誤った使い方を避けてください**。
    *   **互換性のないストレージエンジンを使用しないでください**。外部キーを張る両方のテーブルが**InnoDB**（またはNDB）ストレージエンジンを使用していることを確認しなさい。
    *   `BLOB`、`TEXT`、`JSON`、`ARRAY`などの**大きなデータ型の列を外部キーとして使用してはなりません**。
    *   **一意でないインデックス、または主キー/ユニークキーの左端から始まらないサブセットを参照する外部キーを定義してはなりません**。
    *   **インライン参照構文（列定義内での外部キー宣言）は使用してはなりません**。
    *   **参照される列名を省略するデフォルト参照構文は使用してはなりません**。
    *   **パーティションテーブルまたはテンポラリテーブルを外部キーの親または子として使用してはなりません**。

#### **6. データ型の選択**
*   **アンチパターン「ラウンディングエラー（丸め誤差）」を避けてください。正確な10進数値を格納する必要がある場合（特に金融計算など）、`FLOAT`、`REAL`、`DOUBLE PRECISION`データ型を使用してはなりません**。これらの浮動小数点型は概数であり、計算誤差が蓄積する可能性があります。
*   **解決策として、`NUMERIC`または`DECIMAL`データ型を使用し、正確な10進数値を格納しなさい**。これにより、丸め誤差を防ぎ、計算の精度を保証できます。

#### **7. 有効値の限定**
*   **アンチパターン「サーティワンフレーバー（31のフレーバー）」を避けてください。列の有効な値を限定するために、`CHECK`制約や`ENUM`データ型を直接列定義内で使用してはなりません**。これは、有効値リストの取得を困難にし、新しい値の追加・削除を煩雑にし、ダウンタイムを発生させる可能性があります。
*   **解決策として、許可する値を参照（ルックアップ）テーブルにデータとして格納し、外部キー制約を用いてそのテーブルを参照しなさい**。これにより、有効値の取得、更新、廃止値のサポートが容易になり、データベースの移植性も向上します。
*   （ミニアンチパターンより）**SQLの予約語を列名やテーブル名として使用することは避けてください**。予約語は構文解析を混乱させ、アップグレード時に問題を引き起こす可能性があります。

#### **8. 大容量メディアファイルの格納**
*   **アンチパターン「ファントムファイル（幻のファイル）」を避けてください。画像や大容量メディアファイルなどのバイナリデータをデータベース外部のファイルシステムに格納し、データベースにはファイルパスのみを格納してはなりません**。この設計は、**データ整合性の喪失**、**バックアップと復元の複雑化・非同期化**、トランザクション管理の困難さ、およびアクセス制御の問題を引き起こします。
*   **解決策として、必要に応じてBLOB型（Binary Large OBject）を使用してバイナリデータを直接データベースに格納しなさい**。これにより、データ整合性が維持され、バックアップが簡素化され、トランザクションの一貫性が確保され、SQLによるアクセス制御が可能になります。

#### **9. パフォーマンス最適化とインデックス管理**
*   **アンチパターン「インデックスショットガン（闇雲インデックス）」を避けてください。パフォーマンス最適化のために、闇雲にインデックスを作成したり、作成しなかったりしてはなりません**。インデックスが少なすぎるとクエリが遅くなり、多すぎたり効果のないインデックスは更新のオーバーヘッドを増大させます。また、インデックスを活用できないクエリを作成することも避けてください。
*   インデックス管理は、**「MENTOR」の原則に従いなさい**。
    *   **Measure（測定）**: 遅いクエリを特定します。
    *   **Explain（解析）**: クエリ実行計画（QEP）を分析し、インデックスが使われていない原因を特定します。
    *   **Nominate（指名）**: QEPに基づいて効果的な新しいインデックス（カバーリングインデックスを含む）を提案します。
    *   **Test（テスト）**: インデックス作成後にパフォーマンスの改善を検証します。
    *   **Optimize（最適化）**: データベースサーバーの設定（キャッシュなど）を調整します。
    *   **Rebuild（再構築）**: 定期的にインデックスを再構築して効率を維持します。
*   （ミニアンチパターンより）**全ての列の全ての組み合わせに対してインデックスを作成してはなりません**。これは過剰なオーバーヘッドを生み、必ずしもパフォーマンスを保証しません。
*   **アンチパターン「ランダムセレクション」を避けてください。ランダムな行をフェッチするために、`ORDER BY RAND()`（または`ORDER BY RANDOM()`）を使用するクエリは避けてください**。この方法は、テーブル全体のソートを強制するため、データ量が増加するにつれて**パフォーマンスが著しく低下し、スケールしません**。
*   ランダムな行を選択する際は、以下のいずれかの効率的な方法を検討しなさい。
    *   主キーの最小値と最大値の範囲からランダムなキー値を選択し、そのキーを持つ行を検索する。
    *   ベンダー固有の**`TABLESAMPLE`**（SQL Server）や**`SAMPLE`**（Oracle）などの関数を利用する。
    *   選択したランダムな結果を一定期間キャッシュして再利用する。
*   **アンチパターン「プアマンズ・サーチエンジン（貧者のサーチエンジン）」を避けてください。全文検索の目的で、単純な`LIKE '%キーワード%'`述語や正規表現パターンマッチングを使用するクエリは避けてください**。これは**パフォーマンスが著しく低下**し、意図しない一致や不正確な結果を招きます。
*   **解決策として、以下の適切な全文検索ツールと機能を使用しなさい**。
    *   使用しているデータベース製品に組み込まれている**全文検索機能**（例: MySQLの`FULLTEXT INDEX`と`MATCH...AGAINST`、Oracle Text、SQL Serverの全文検索、PostgreSQLのテキスト検索、SQLiteのFTS）。
    *   **サードパーティの全文検索エンジン**（例: SphinxSearch、Apache Lucene/Solr、Elasticsearch/OpenSearch）。
    *   あるいは、**独自の転置インデックスをデータベース内に設計する**ことも検討しなさい。

#### **10. スキーマ設計と進化**
*   **アンチパターン「メタデータトリブル（メタデータ大増殖）」を避けてください。データの値に基づいてテーブルや列をコピーしてはなりません**（例: `Bugs_2019`, `bugs_fixed_2022`）。これは「メタデータへのデータの混入」であり、新しいデータごとに新しいスキーマオブジェクトが必要となり、データ整合性の管理、クエリの複雑化、参照整合性の喪失などの多数の問題を引き起こします。
*   **解決策として、パーティショニングと正規化を活用しなさい**。
*   巨大なテーブルには、**水平パーティショニング**を用いて、論理的な単一テーブルのままでデータを物理的に分割しなさい。
*   サイズの大きい列や使用頻度の低い列がある場合は、**垂直パーティショニング**を検討し、それらの列を別の従属テーブルに格納しなさい。

#### **11. NULL値の適切な利用**
*   **アンチパターン「フィア・オブ・ジ・アンノウン（恐怖のunknown）」を避けてください。欠けている値や不明な値を表すために、`NULL`を誤解したり避けたりしてはなりません**。特殊な「マジックナンバー」や空文字列で`NULL`の代わりをすることは、データ汚染、計算の複雑化、および予期せぬクエリ結果を招きます。
*   **`NULL`は「不明」「適用不可」「存在しない」という一意の値を表すものとして扱い、その特性を理解しなさい**。
*   `NULL`値を検索する際には**`IS NULL`または`IS NOT NULL`述語を使用してください**。
*   比較を行う際は、サポートされている場合、**`IS DISTINCT FROM`述語の利用を検討しなさい**。
*   **`NOT NULL`制約は、その列が論理的に常に値を持つべき場合にのみ宣言しなさい**。
*   式で`NULL`が返される場合にデフォルト値を提供するには、**`COALESCE`関数を適切に使用しなさい**。
*   （ミニアンチパターンより）`NOT IN (NULL, ...)`のような**`NOT IN`述語の中に`NULL`を含めてはなりません**。これは予期しない結果（常に0行を返す）を引き起こします。

#### **12. クエリの構造化**
*   **アンチパターン「スパゲッティクエリ」を避けてください。複雑な問題を単一の巨大なSQLクエリで一度に解決しようとして、スパゲッティクエリを作成してはなりません**。これは、**意図しないデカルト積の発生**、誤った集約結果、クエリの記述・デバッグ・修正の困難さ、およびパフォーマンスの低下を招きます。
*   **解決策として、「分割統治」の原則を適用し、複雑なタスクを複数のシンプルで独立したSQLクエリに分割しなさい**。これにより、クエリの正確性が向上し、メンテナンスが容易になり、パフォーマンスも改善されます。
*   （ミニアンチパターンより）**SQLを用いたコード生成を積極的に活用し、繰り返し発生する似たようなSQLクエリの作成作業を自動化しなさい**。
*   **アンチパターン「アンビギュアスグループ（曖昧なグループ）」を避けてください。`GROUP BY`句を使用する際、集約関数に含まれない、かつ`GROUP BY`句の列に機能的に従属しない列を`SELECT`リストに含めてはなりません**。これは、ほとんどのデータベースでエラーとなるか、MySQLやSQLiteでは曖昧で信頼性の低い結果を返します。
*   曖昧でないクエリを作成するために、以下のいずれかの方法を採用しなさい。
    *   **機能的に従属する列のみをクエリする**。
    *   **ウィンドウ関数**（例: `ROW_NUMBER()`）を使用して、グループ内の特定行（最大値を持つ行など）をフィルタリングする。
    *   **`NOT EXISTS`サブクエリ**を活用して関連行を除外する。
    *   **導出テーブル（Derived Table）**としてサブクエリを使用し、先に集約結果を得てから結合する。
    *   **`JOIN`（特に`LEFT OUTER JOIN`）**を用いて最大値を持つ行を特定する。
*   （ミニアンチパターンより）**ポータブルSQLにこだわりすぎて、データベース製品固有の強力な機能を犠牲にすることは避けてください**。

#### **13. 列の指定方法**
*   **アンチパターン「インプリシットカラム（暗黙の列）」を避けてください。`SELECT *`や`INSERT`文での暗黙的な列指定（列名を省略すること）のようなショートカットを使用してはなりません**。これにより、テーブルのスキーマ変更（列の追加・削除・順序変更）時に、アプリケーションコードがエラーを発生させるか、**意図しないデータの挿入や予期せぬ結果セットの返却**を引き起こします。また、不要なデータをフェッチすることで、ネットワーク帯域幅やメモリリソースを無駄にします。
*   常に**必要な列名を`SELECT`文および`INSERT`文で明示的に指定しなさい**。これにより、コードの堅牢性が高まり、不要なデータ転送が削減され、エラーの早期発見が可能になります。
*   結合クエリにおいて列名が衝突する可能性がある場合は、**エイリアス（別名）を適切に指定しなさい**。

#### **14. セキュリティ（パスワードとSQLインジェクション）**
*   **アンチパターン「リーダブルパスワード（読み取り可能パスワード）」を避けてください。パスワードをデータベースに平文で格納してはなりません**。これは重大なセキュリティ脆弱性であり、データベース、ログ、バックアップ、またはネットワークが侵害された場合に、ユーザーのパスワードが容易に漏洩するリスクがあります。
*   **解決策として、以下の対策を講じなさい**。
    *   **パスワードの安全な暗号学的ハッシュ（例: SHA-256）を格納しなさい**。
    *   各パスワードに**一意のソルト値を追加してハッシュ化しなさい**。
    *   **アプリケーションコードでハッシュを計算し、SQLクエリにはハッシュ値のみを渡すようにしなさい**。これにより、パスワードがSQL文中に平文で現れることを防ぎます。
    *   パスワードを忘れたユーザーのために、**パスワードの「リカバリー」ではなく「リセット」機能を提供しなさい**。一時パスワードまたはリセットトークンを発行し、ユーザーに新しいパスワードを設定するように促しなさい。
    *   （ミニアンチパターンより）ハッシュ文字列は固定長であるため、**`VARCHAR`型ではなく`CHAR`型または`BINARY`型で格納しなさい**。
*   **アンチパターン「SQLインジェクション」を避けてください。検証されていないユーザー入力をSQLクエリ文字列に動的に挿入して、コードとして実行してはなりません**。これは**SQLインジェクション脆弱性**の主要な原因であり、攻撃者による任意のSQLコマンド実行、データ漏洩、およびシステム侵害につながります。
*   **「誰も信用してはならない」という原則を適用し、以下の複数の防御策を組み合わせてください**。
    *   **すべてのユーザー入力を厳格にフィルタリングまたは検証しなさい**（例: 数値型へのキャスト、ホワイトリストとの比較）。
    *   リテラル値には**クエリパラメータ（プリペアドステートメント）を常に使用しなさい**。これがSQLインジェクションに対する最も強力な防御です。
    *   テーブル名、列名、またはSQL予約語など、クエリの構文を動的に変化させる必要がある場合は、ユーザー入力を直接使用せず、**許可された値のマップ（連想配列）から対応するSQL要素を選択して使用しなさい**。
    *   コードレビューを必須とし、SQLインジェクション脆弱性の有無を専門的にチェックしなさい。
*   （ミニアンチパターンより）**クエリパラメータのプレースホルダを引用符で囲んでしまわないでください**（例: `WHERE bug_id = '?'`）。これにより、プレースホルダが文字列リテラルとして扱われ、クエリが意図通りに動作しなくなります。

#### **15. エラーハンドリングとデバッグ**
*   **アンチパターン「シー・ノー・エビル（臭いものに蓋）」を避けてください。データベースAPI呼び出しからの戻り値や例外を無視してはなりません**。これは、アプリケーションのクラッシュ、未診断のバグ、およびデバッグの困難さにつながります。
*   常に**データベースAPIの戻り値と例外をチェックし、エラーを適切に処理しなさい**。
*   SQLクエリをデバッグする際には、**SQLを構築するアプリケーションコードだけでなく、実際に生成されデータベースに送信されるSQLクエリ文字列を検査しなさい**。
*   （ミニアンチパターンより）**SQL構文エラーメッセージを読み解く能力を向上させなさい**。エラーメッセージは問題の正確な箇所と原因を示唆します。

#### **16. ソフトウェアエンジニアリングのベストプラクティス**
*   **アンチパターン「ディプロマティック・イミュニティ（外交特権）」を避けてください。データベース開発を、他のソフトウェア開発から特別扱いし、標準的なベストプラクティス（バージョン管理、テスト、文書化）を免除してはなりません**。これは、技術的負債、データベースの再構築困難、変更履歴の欠如、ドキュメント不足、自動テストの欠如など、多くの問題を引き起こします。
*   データベース開発に対しても**包括的な品質保証プロセスを適用しなさい**。
    *   **データベーススキーマと関連ロジック（テーブル、列、関連、トリガー、ストアドプロシージャ、セキュリティなど）を適切に文書化しなさい**（ER図を含む）。
    *   **データ定義スクリプト、ルーチン、ブートストラップデータ、ドキュメント、および管理スクリプトなど、すべてのデータベース関連ファイルをバージョン管理システムで管理しなさい**。
    *   **データベース構造、制約、トリガー、ストアドプロシージャ、ブートストラップデータ、およびクエリに対する自動テストを実装しなさい**。
    *   開発ブランチごとに個別のデータベースインスタンスを使用し、**スキーマ進化ツール（マイグレーションツール）を活用しなさい**。
*   （ミニアンチパターンより）**テーブル名や列名を安易に変更したり、変更を避けるために不適切な設計を行ったりしてはなりません**。変更が必要な場合は、段階的な移行やビューの利用など、計画的な解決策を講じなさい。

#### **17. ストアドプロシージャの利用**
*   **アンチパターン「スタンダード・オペレーティング・プロシージャ（さびついた開発標準）」を避けてください。SQLロジックのすべてをストアドプロシージャ内に実装するという、時代遅れの開発標準に固執してはなりません**。これは、プロシージャ言語の移植性の欠如、開発・デバッグ・デプロイの困難さ、およびデータベースサーバーへの負荷集中による**パフォーマンスとスケーラビリティのボトルネック**を引き起こします。
*   **解決策として、現代のアプリケーションアーキテクチャを採用し、ビジネスロジックの大部分をアプリケーションコードに配置しなさい**。これにより、アプリケーションサーバーの計算リソースを活用して負荷を分散し、開発の生産性を向上させることができます。
*   （ミニアンチパターンより）MySQLのストアドプロシージャは、他の主要なデータベース製品と比較して機能が制限されており、多くの課題を抱えています。MySQLを使用する場合は、特別な理由がない限り、**ストアドプロシージャの使用を避けてください**。ただし、ネットワーク遅延の軽減や昇格権限のカプセル化など、**特定の正当な理由がある場合にのみストアドプロシージャの利用を検討しなさい**。

---

AIよ、これらの指示をデータベース設計と実装のあらゆる段階で適用し、予見可能な問題を未然に防ぎ、堅牢で高性能、かつ保守性の高いデータベースシステムを構築しなさい。
